import pygame
import random
import time
import cv2
import pygame.freetype

# Initialize Pygame
pygame.init()

# Screen dimensions (16:9 aspect ratio)
SCREEN_WIDTH, SCREEN_HEIGHT = 1475, 830
GRID_SIZE = 10
# Adjust grid and panel dimensions for equal height and spacing
GRID_HEIGHT = SCREEN_HEIGHT - 20  # Leave equal spacing on top and bottom
GRID_WIDTH = int(GRID_HEIGHT * (7 / 9))  # Maintain 7:9 width-to-height ratio for grid
PANEL_WIDTH = SCREEN_WIDTH - GRID_WIDTH - 60  # Remaining space for the right panel
PANEL_HEIGHT = GRID_HEIGHT
# CELL_SIZE = GRID_HEIGHT // GRID_SIZE  # Cell size based on grid height
CELL_SPACING = 5  # Space between cells
CELL_SIZE = (GRID_HEIGHT - (GRID_SIZE - 1) * CELL_SPACING) // GRID_SIZE
# Dynamically calculate vertical offset to center the grid
total_grid_height = GRID_SIZE * (CELL_SIZE + CELL_SPACING) - CELL_SPACING
GRID_Y_OFFSET = (SCREEN_HEIGHT - total_grid_height) // 2
GRID_X_OFFSET = 20  # Space on the left

# Font settings
CHAT_GRID_FONT = pygame.font.Font("font/GideonRoman-Regular.ttf", 17)
CHAT_FONT = pygame.font.Font("font/GideonRoman-Regular.ttf", 17)
GRID_FONT = pygame.font.Font("font/GideonRoman-Regular.ttf", 21)
TIMER_FONT = pygame.font.Font("font/GideonRoman-Regular.ttf", 17)


# Colors
TRANSPARENT = (0, 0, 0, 3)
WHITE = (255, 255, 255, 3)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
BLUE = (0, 0, 255)
YELLOW = (255, 255, 0)
GOLD = (255, 215, 0)

GRID_COLOR = (255, 255, 255, 3)
GRID_FONT_COLOR = (33, 33, 33, 1)
CHAT_COLOR = (255, 255, 255, 3)
CHAT_FONT_COLOR = (33, 33, 33, 1)

def apply_rounded_mask(image, radius=CELL_SIZE // 5):
    mask = pygame.Surface((CELL_SIZE, CELL_SIZE), pygame.SRCALPHA)
    pygame.draw.rect(mask, (255, 255, 255, 255), (0, 0, CELL_SIZE, CELL_SIZE), border_radius=10)
    rounded_image = pygame.Surface((CELL_SIZE, CELL_SIZE), pygame.SRCALPHA)
    rounded_image.blit(image, (0, 0))
    rounded_image.blit(mask, (0, 0), special_flags=pygame.BLEND_RGBA_MIN)
    return rounded_image


PLAYER_IMAGES = []

# Load Medusa and Hedone backgrounds
MEDUSA_BACKGROUND = pygame.transform.smoothscale(pygame.image.load("char/medusa/medusa1.png"), (int(SCREEN_WIDTH * 0.7), SCREEN_HEIGHT))
HEDONE_BACKGROUND = pygame.transform.smoothscale(pygame.image.load("char/hedone/hedone1.png"), (int(SCREEN_WIDTH * 0.7), SCREEN_HEIGHT))

MEDUSA_IMAGES = [
    pygame.image.load(f"char/medusa/medusa{i}.png") for i in range(1, 11)
]
HEDONE_IMAGES = [
    pygame.image.load(f"char/hedone/hedone{i}.png") for i in range(1, 11)
]

MEDUSA_IMAGES = [
    pygame.transform.smoothscale(image, (CELL_SIZE, CELL_SIZE))
    for image in MEDUSA_IMAGES
]
HEDONE_IMAGES = [
    pygame.transform.smoothscale(image, (CELL_SIZE, CELL_SIZE))
    for image in HEDONE_IMAGES
]

MEDUSA_BACKGROUNDS = [
    pygame.image.load(f"char/medusa/medusa{i}.png") for i in range(1, 11)
]
HEDONE_BACKGROUNDS = [
    pygame.image.load(f"char/hedone/hedone{i}.png") for i in range(1, 11)
]
MEDUSA_BACKGROUNDS = [
    pygame.transform.smoothscale(img, (int(SCREEN_WIDTH * 0.7), SCREEN_HEIGHT)) for img in MEDUSA_BACKGROUNDS
]
HEDONE_BACKGROUNDS = [
    pygame.transform.smoothscale(img, (int(SCREEN_WIDTH * 0.7), SCREEN_HEIGHT)) for img in HEDONE_BACKGROUNDS
]

MEDUSA_IMAGES = [
    apply_rounded_mask(pygame.transform.smoothscale(image, (CELL_SIZE, CELL_SIZE)))
    for image in MEDUSA_IMAGES
]
HEDONE_IMAGES = [
    apply_rounded_mask(pygame.transform.smoothscale(image, (CELL_SIZE, CELL_SIZE)))
    for image in HEDONE_IMAGES
]



# Load single intro image
INTRO_IMAGE = pygame.transform.smoothscale(pygame.image.load("char/io.png"), (int(SCREEN_WIDTH), SCREEN_HEIGHT))

INTRO_VIDEO_PATH = "char/intro/intro.mp4"


def play_intro_video():
    cap = cv2.VideoCapture(INTRO_VIDEO_PATH)

    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break

        frame_height, frame_width = frame.shape[:2]
        aspect_ratio = 16 / 9
        if frame_width / frame_height > aspect_ratio:
            # Wider than 16:9, fit by height
            new_height = SCREEN_HEIGHT
            new_width = int(new_height * aspect_ratio)
        else:
            # Taller than 16:9, fit by width
            new_width = SCREEN_WIDTH
            new_height = int(new_width / aspect_ratio)

        frame = cv2.resize(frame, (new_width, new_height))
        frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        frame_surface = pygame.surfarray.make_surface(frame.swapaxes(0, 1))

        # Center the frame on the screen
        x_offset = (SCREEN_WIDTH - new_width) // 2
        y_offset = (SCREEN_HEIGHT - new_height) // 2
        screen.fill(GRID_COLOR)  # Clear the screen
        screen.blit(frame_surface, (x_offset, y_offset))
        pygame.display.flip()

        if cv2.waitKey(20) & 0xFF == ord('q'):
            break

    cap.release()
    cv2.destroyAllWindows()

def load_player_images(num_players):
    def load_high_quality_image(path):
        image = pygame.image.load(path).convert_alpha()
        return pygame.transform.smoothscale(image, (CELL_SIZE, CELL_SIZE))
    if num_players == 2:
        return [
            load_high_quality_image("char/eros.png"),
            load_high_quality_image("char/psyche.png")
        ]
    elif num_players == 3:
        return [
            load_high_quality_image("char/ares.png"),
            load_high_quality_image("char/aphrodite.png"),
            load_high_quality_image("char/eos.png")
        ]
    elif num_players == 4:
        return [
            load_high_quality_image("char/zeus.png"),
            load_high_quality_image("char/hera.png"),
            load_high_quality_image("char/semele.png"),
            load_high_quality_image("char/io.png")
        ]

    return []



# Initialize screen
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Hedone and Himeros")

# Chat panel setup
chat_panel = []
def update_chat(message):
    chat_panel.append(message)
    if len(chat_panel) > 15:
        chat_panel.pop(0)


def draw_timer(countdown_time):
    remaining_time = max(0, int(countdown_time - time.time()))
    minutes = remaining_time // 60
    seconds = remaining_time % 60
    timer_text = TIMER_FONT.render(f"Time Left: {minutes:02}:{seconds:02}", True, CHAT_FONT_COLOR)

    panel_x = int(SCREEN_WIDTH * 0.7)
    panel_width = SCREEN_WIDTH - panel_x

    # Draw timer background with the same dimensions as the chat panel
    timer_rect = pygame.Rect(panel_x + 10, 10, panel_width - 20, 50)
    pygame.draw.rect(screen, CHAT_COLOR, timer_rect, border_radius=10)  # Rounded corners
    pygame.draw.rect(screen, CHAT_FONT_COLOR, timer_rect, 1, border_radius=10)  # Outline with rounded corners


    # Draw timer text
    screen.blit(timer_text, (timer_rect.x + 10 , timer_rect.y + 10))

def draw_chat():
    panel_x = int(SCREEN_WIDTH * 0.7)
    panel_width = SCREEN_WIDTH - panel_x
    chat_y_offset = int(SCREEN_HEIGHT * 0.1)
    max_text_width = panel_width - 20  # Adjust for padding

    # Draw the chat panel background with rounded corners
    chat_rect = pygame.Rect(panel_x + 10, chat_y_offset, panel_width - 20, SCREEN_HEIGHT - chat_y_offset - 70)  # Adjust height for dice panel
    pygame.draw.rect(screen, CHAT_COLOR, chat_rect, border_radius=10)  # Rounded corners
    pygame.draw.rect(screen, CHAT_FONT_COLOR, chat_rect, 1, border_radius=10)  # Border with rounded corners

    # Draw chat messages with text wrapping
    y_position = chat_rect.y + 5  # Start with some padding
    for message in chat_panel:
        words = message.split(" ")
        line = ""
        for word in words:
            test_line = line + word + " "
            rendered_text = CHAT_FONT.render(test_line.strip(), True, CHAT_FONT_COLOR)
            if rendered_text.get_width() > max_text_width:
                # Render the current line and start a new one
                rendered_text = CHAT_FONT.render(line.strip(), True, CHAT_FONT_COLOR)
                screen.blit(rendered_text, (chat_rect.x + 10, y_position))
                y_position += CHAT_FONT.get_height() + 5
                line = word + " "
            else:
                line = test_line
        # Render the last line
        if line:
            rendered_text = CHAT_FONT.render(line.strip(), True, CHAT_FONT_COLOR)
            screen.blit(rendered_text, (chat_rect.x + 10, y_position))
            y_position += CHAT_FONT.get_height() + 5


# Create the board
def draw_board(action_positions, snake_tiles={}, ladder_tiles={}):
    for row in range(GRID_SIZE):
        for col in range(GRID_SIZE):
            if row % 2 == 0:  # Even rows go right to left
                position = (GRID_SIZE * (GRID_SIZE - row - 1)) + (GRID_SIZE - col - 1) + 1
            else:  # Odd rows go left to right
                position = (GRID_SIZE * (GRID_SIZE - row - 1)) + col + 1

            rect_x = GRID_X_OFFSET + col * (CELL_SIZE + CELL_SPACING)
            rect_y = GRID_Y_OFFSET + row * (CELL_SIZE + CELL_SPACING)
            rect = pygame.Rect(rect_x, rect_y, CELL_SIZE, CELL_SIZE)

            # Check if the tile should display a Medusa or Hedone image
            if position in snake_tiles:
                screen.blit(snake_tiles[position], rect.topleft)
            elif position in ladder_tiles:
                screen.blit(ladder_tiles[position], rect.topleft)

            overlay = pygame.Surface((CELL_SIZE, CELL_SIZE), pygame.SRCALPHA)
            overlay.fill((173, 216, 230, 8))  # Pastel blue with 30% opacity
            pygame.draw.rect(overlay, (0, 0, 0, 0), rect, border_radius=10)  # Rounded cell edges
            screen.blit(overlay, rect.topleft)
            pygame.draw.rect(screen, GRID_FONT_COLOR, rect, 1, border_radius=10)

            text = GRID_FONT.render(str(position), True, GRID_FONT_COLOR)
            screen.blit(text, (rect.x + 5, rect.y + 5))




# Generate snakes and ladders
def generate_snakes_and_ladders():
    snakes = {}
    ladders = {}
    snake_medusa_mapping = {}
    ladder_hedone_mapping = {}
    snake_background_mapping = {}
    ladder_background_mapping = {}

    for level_index, level_start in enumerate(range(1, 101, 10)):
        level_end = level_start + 9

        # Generate one snake per level
        while True:
            start = random.randint(level_start + 1, level_end)
            end = random.randint(level_start, start - 1)
            if start - end <= 5 and start not in snakes and start not in ladders and end > level_start:
                snakes[start] = end
                break

        # Assign the corresponding Medusa image to the snake
        snake_medusa_mapping[start] = MEDUSA_IMAGES[level_index % 10]
        snake_background_mapping[start] = MEDUSA_BACKGROUNDS[level_index % 10]


        # Generate one ladder per level
        while True:
            start = random.randint(level_start, level_end - 1)
            end = random.randint(start + 1, level_end)
            if end - start <= 5 and start not in ladders and start not in snakes:
                ladders[start] = end
                break

        # Assign the corresponding Hedone image to the ladder
        ladder_hedone_mapping[start] = HEDONE_IMAGES[level_index % 10]
        ladder_background_mapping[start] = HEDONE_BACKGROUNDS[level_index % 10]

    return snakes, ladders, snake_medusa_mapping, ladder_hedone_mapping, snake_background_mapping, ladder_background_mapping

snakes, ladders, snake_medusa_mapping, ladder_hedone_mapping, snake_bg_mapping, ladder_bg_mapping = generate_snakes_and_ladders()

# Draw snakes and ladders using custom styles
def draw_snakes_and_ladders():
    for start, end in snakes.items():
        start_pos = get_coordinates(start)
        end_pos = get_coordinates(end)

        # Create curvy wavy effect for snakes
        num_segments = 10  # Number of segments for the curve
        x_diff = (end_pos[0] - start_pos[0]) / num_segments
        y_diff = (end_pos[1] - start_pos[1]) / num_segments
        points = []
        for i in range(num_segments + 1):
            x = start_pos[0] + i * x_diff + CELL_SIZE // 6 * (-1)**i
            y = start_pos[1] + i * y_diff
            points.append((x + CELL_SIZE // 2, y + CELL_SIZE // 2))  # Center-align the wave

        # Snakes are now invisible
        pygame.draw.lines(screen, TRANSPARENT, False, points, 8)

    for start, end in ladders.items():
        start_pos = get_coordinates(start)
        end_pos = get_coordinates(end)
        # Ladders are now invisible
        pygame.draw.line(screen, TRANSPARENT, (start_pos[0] + CELL_SIZE // 2, start_pos[1] + CELL_SIZE // 2),
                         (end_pos[0] + CELL_SIZE // 2, end_pos[1] + CELL_SIZE // 2), 5)  # Draw the wavy snake

    for start, end in ladders.items():
        start_pos = get_coordinates(start)
        end_pos = get_coordinates(end)
        pygame.draw.line(screen, GOLD, (start_pos[0] + CELL_SIZE // 2, start_pos[1] + CELL_SIZE // 2),
                         (end_pos[0] + CELL_SIZE // 2, end_pos[1] + CELL_SIZE // 2), 5)  # Shiny golden ladder

# Convert board index to screen coordinates
def get_coordinates(position):
    position -= 1
    row = position // GRID_SIZE
    if row % 2 == 0:  # Even rows go right to left
        col = position % GRID_SIZE
    else:  # Odd rows go left to right
        col = GRID_SIZE - 1 - (position % GRID_SIZE)

    x = GRID_X_OFFSET + col * (CELL_SIZE + CELL_SPACING)
    y = GRID_Y_OFFSET + (GRID_SIZE - 1 - row) * (CELL_SIZE + CELL_SPACING)
    return x, y



# Smooth movement animation
def animate_movement(start, end, player_index, background_override=None):
    step = 1 if end > start else -1
    for position in range(start, end + step, step):
        if background_override:
            screen.blit(background_override, (0, 0))  # Draw override background
        else:
            screen.fill(GRID_COLOR)  # Clear screen to white

        draw_board(action_positions, snake_tiles, ladder_tiles)
        draw_snakes_and_ladders()
        draw_players()
        draw_chat()
        draw_timer(countdown_end)

        x, y = get_coordinates(position)
        x_centered = x + (CELL_SIZE - PLAYER_IMAGES[player_index].get_width()) // 2
        y_centered = y + (CELL_SIZE - PLAYER_IMAGES[player_index].get_height()) // 2

        screen.blit(PLAYER_IMAGES[player_index], (x_centered, y_centered))  # Align image with rounded cell padding
        pygame.display.flip()
        time.sleep(0.2)



# Load actions
def load_actions():
    actions = {
        "L1": ["Action for L1"],
        "L2": ["Action for L2"],
        "L3": ["Action for L3"],
        "L4": ["Action for L4"],
        "L5": ["Action for L5"],
        "L6": ["Action for L6"],
        "L7": ["Action for L7"],
        "L8": ["Action for L8"],
        "L9": ["Action for L9"],
        "L10": ["Action for L10"]
    }
    return actions

actions = load_actions()

def get_action(position):
    if 1 <= position <= 10:
        return random.choice(actions["L1"])
    elif 11 <= position <= 20:
        return random.choice(actions["L2"])
    elif 21 <= position <= 30:
        return random.choice(actions["L3"])
    elif 31 <= position <= 40:
        return random.choice(actions["L4"])
    elif 41 <= position <= 50:
        return random.choice(actions["L5"])
    elif 51 <= position <= 60:
        return random.choice(actions["L6"])
    elif 61 <= position <= 70:
        return random.choice(actions["L7"])
    elif 71 <= position <= 80:
        return random.choice(actions["L8"])
    elif 81 <= position <= 90:
        return random.choice(actions["L9"])
    elif 91 <= position <= 100:
        return random.choice(actions["L10"])
    else:
        return "No Action"

# Initialize players
def initialize_players():
    global PLAYER_IMAGES
    while True:
        try:
            num_players = int(input("Enter the number of players (2-4): "))
            if num_players == 2:
                player_names = ["Eros", "Psyche"]
                update_chat("Welcome Eros and Psyche!")
                PLAYER_IMAGES = [
                    apply_rounded_mask(image) for image in load_player_images(2)
                ]
            elif num_players == 3:
                player_names = ["Ares", "Aphrodite", "Eos"]
                update_chat("Welcome Ares, Aphrodite, and Eos!")
                PLAYER_IMAGES = [
                    apply_rounded_mask(image) for image in load_player_images(2)
                ]
            elif num_players == 4:
                player_names = ["Zeus", "Hera", "Semele", "Io"]
                update_chat("Welcome Zeus, Hera, Semele, and Io!")
                PLAYER_IMAGES = [
                    apply_rounded_mask(image) for image in load_player_images(2)
                ]
            else:
                print("Invalid number of players. Please choose between 2 and 4.")
                continue

            # Show start image for 5 seconds
            # screen.blit(INTRO_IMAGE, (0, 0))
            # pygame.display.flip()
            # time.sleep(9)

            play_intro_video()

            break
        except ValueError:
            print("Invalid input. Please enter a number.")

    player_positions = [1 for _ in range(num_players)]
    return player_names, player_positions

players, player_positions = initialize_players()
current_player_idx = 0

def draw_dice_panel(input_value):
    panel_x = int(SCREEN_WIDTH * 0.7)
    panel_width = SCREEN_WIDTH - panel_x
    dice_panel_rect = pygame.Rect(panel_x + 10, SCREEN_HEIGHT - 60, panel_width - 20, 50)  # Positioned at the bottom
    pygame.draw.rect(screen, CHAT_COLOR, dice_panel_rect, border_radius=10)  # Rounded corners
    pygame.draw.rect(screen, CHAT_FONT_COLOR, dice_panel_rect, 1, border_radius=10)  # Border with rounded corners

    input_text = CHAT_FONT.render(f"Enter Dice Value (1-6): {input_value}", True, CHAT_FONT_COLOR)
    screen.blit(input_text, (dice_panel_rect.x + 10, dice_panel_rect.y + 10))

def get_dice_value():
    global countdown_end
    input_value = ""
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                exit()

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_RETURN and input_value.isdigit() and 1 <= int(input_value) <= 6:
                    return int(input_value)
                elif event.key == pygame.K_BACKSPACE:
                    input_value = input_value[:-1]
                else:
                    input_value += event.unicode

        screen.fill(GRID_COLOR)  # Clear screen to white
        draw_board(action_positions, snake_tiles, ladder_tiles)
        draw_snakes_and_ladders()
        draw_players()
        draw_chat()
        draw_timer(countdown_end)
        # input_text = CHAT_FONT.render(f"Enter Dice Value (1-6): {input_value}", True, CHAT_FONT_COLOR)
        # screen.blit(input_text, (int(SCREEN_WIDTH * 0.7) + 5, SCREEN_HEIGHT - 40))
        draw_dice_panel(input_value)  # Draw the separate dice input panel
        pygame.display.flip()

# Draw players
def draw_players():
    for i, position in enumerate(player_positions):
        x, y = get_coordinates(position)
        screen.blit(PLAYER_IMAGES[i], (x, y))  # Align image with cell

# Main game loop
running = True
winner = None
action_positions = {}
snake_tiles = {}
ladder_tiles = {}
countdown_end = time.time()
while running:
    screen.fill(GRID_COLOR)  # Clear screen to white
    draw_board(action_positions, snake_tiles, ladder_tiles)
    draw_snakes_and_ladders()
    draw_players()
    draw_chat()
    draw_timer(countdown_end)

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    if not winner:
        dice_value = get_dice_value()
        current_player = players[current_player_idx % len(players)]
        # update_chat(f"{current_player} rolled a {dice_value}!")

        # Logic for rolling 6s
        six_count = 0
        turn_total = 0

        while True:
            if dice_value == 6:
                six_count += 1
                if six_count == 3:
                    update_chat(f"{current_player} rolled three 6s! Turn skipped.")
                    break
                else:
                    update_chat(f"{current_player} rolled a 6! Another chance!")
                dice_value = get_dice_value()
            else:
                turn_total += 6 * six_count + dice_value
                new_pos = player_positions[current_player_idx] + turn_total

                if new_pos > 100:
                    update_chat("Roll exceeds 100! Stay in place.")
                else:
                    if new_pos in snakes:
                        animate_movement(player_positions[current_player_idx], new_pos, current_player_idx)
                        animate_movement(new_pos, snakes[new_pos], current_player_idx, snake_bg_mapping[new_pos])
                        update_chat(f"{current_player} encountered Medusa's wrath! You now need to get Spanked!")
                        snake_tiles[new_pos] = snake_medusa_mapping[new_pos]
                        player_positions[current_player_idx] = snakes[new_pos]
                        countdown_end = time.time() + player_positions[current_player_idx] * 2
                    elif new_pos in ladders:
                        animate_movement(player_positions[current_player_idx], new_pos, current_player_idx)
                        animate_movement(new_pos, ladders[new_pos], current_player_idx, ladder_bg_mapping[new_pos])
                        update_chat(f"{current_player} is embraced by Hedone’s delight and Himeros’ desire! You may now experience a delightful action of your choosing!")
                        ladder_tiles[new_pos] = ladder_hedone_mapping[new_pos]
                        player_positions[current_player_idx] = ladders[new_pos]
                        countdown_end = time.time() + player_positions[current_player_idx] * 2
                    else:
                        animate_movement(player_positions[current_player_idx], new_pos, current_player_idx)
                        player_positions[current_player_idx] = new_pos
                        countdown_end = time.time() + player_positions[current_player_idx] * 2

                    action = get_action(player_positions[current_player_idx])
                    update_chat(f"{current_player} performs: {action}")

                    if player_positions[current_player_idx] == 100:
                        winner = current_player
                        update_chat(f"{winner} wins the game! Congratulations!")

                break

        current_player_idx = (current_player_idx + 1) % len(players)

    pygame.display.flip()

pygame.quit()
