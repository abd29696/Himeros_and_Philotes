import pygame
import random
import time

# Initialize Pygame
pygame.init()

# Screen dimensions
SCREEN_WIDTH, SCREEN_HEIGHT = 1200, 840
GRID_SIZE = 10
CELL_SIZE = int((SCREEN_WIDTH * 0.7) // GRID_SIZE)  # Adjusted cell size
GRID_Y_OFFSET = 0  # Removed top margin
FONT = pygame.font.Font(None, 20)  # Slightly reduced font size for chat
TIMER_FONT = pygame.font.Font(None, 20)  # Slightly reduced font size for timer

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
BLUE = (0, 0, 255)
YELLOW = (255, 255, 0)
GOLD = (255, 215, 0)

PLAYER_IMAGES = []

def load_player_images(num_players):
    def load_high_quality_image(path):
        image = pygame.image.load(path).convert_alpha()
        return pygame.transform.smoothscale(image, (CELL_SIZE, CELL_SIZE))
    if num_players == 2:
        return [
            pygame.transform.smoothscale(pygame.image.load("char/eros.png"), (CELL_SIZE, CELL_SIZE)),
            pygame.transform.smoothscale(pygame.image.load("char/psyche.png"), (CELL_SIZE, CELL_SIZE))
        ]
    elif num_players == 3:
        return [
            pygame.transform.smoothscale(pygame.image.load("char/ares.png"), (CELL_SIZE, CELL_SIZE)),
            pygame.transform.smoothscale(pygame.image.load("char/aphrodite.png"), (CELL_SIZE, CELL_SIZE)),
            pygame.transform.smoothscale(pygame.image.load("char/eos.png"), (CELL_SIZE, CELL_SIZE))
        ]
    elif num_players == 4:
        return [
            pygame.transform.smoothscale(pygame.image.load("char/zeus.png"), (CELL_SIZE, CELL_SIZE)),
            pygame.transform.smoothscale(pygame.image.load("char/hera.png"), (CELL_SIZE, CELL_SIZE)),
            pygame.transform.smoothscale(pygame.image.load("char/semele.png"), (CELL_SIZE, CELL_SIZE)),
            pygame.transform.smoothscale(pygame.image.load("char/io.png"), (CELL_SIZE, CELL_SIZE))
        ]
    return []

# Initialize screen
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Snakes and Ladders")

# Chat panel setup
chat_panel = []
def update_chat(message):
    chat_panel.append(message)
    if len(chat_panel) > 15:
        chat_panel.pop(0)

def draw_timer(countdown_time):
    remaining_time = max(0, int(countdown_time - time.time()))
    minutes = remaining_time // 60
    seconds = remaining_time % 60
    timer_text = TIMER_FONT.render(f"Time Left: {minutes:02}:{seconds:02}", True, BLACK)
    panel_x = int(SCREEN_WIDTH * 0.7)
    screen.blit(timer_text, (panel_x + 10, 10))

def draw_chat():
    panel_x = int(SCREEN_WIDTH * 0.7)
    panel_width = SCREEN_WIDTH - panel_x
    chat_y_offset = int(SCREEN_HEIGHT * 0.1)

    # Draw the upper section for the timer
    pygame.draw.rect(screen, WHITE, (panel_x, 0, panel_width, chat_y_offset))
    pygame.draw.rect(screen, BLACK, (panel_x, 0, panel_width, chat_y_offset), 1)

    # Draw the lower section for the chat
    pygame.draw.rect(screen, WHITE, (panel_x, chat_y_offset, panel_width, SCREEN_HEIGHT - chat_y_offset))
    pygame.draw.rect(screen, BLACK, (panel_x, chat_y_offset, panel_width, SCREEN_HEIGHT - chat_y_offset), 1)

    for i, line in enumerate(chat_panel):
        text = FONT.render(line, True, BLACK)
        screen.blit(text, (panel_x + 5, chat_y_offset + 10 + i * 15))

# Create a gradient background
def draw_gradient_background():
    for y in range(SCREEN_HEIGHT):
        color_ratio = y / SCREEN_HEIGHT
        r = int((1 - color_ratio) * 144 + color_ratio * 244)  # Pastel gradient from green to red
        g = int((1 - color_ratio) * 238 + color_ratio * 83)
        b = int((1 - color_ratio) * 144 + color_ratio * 83)
        pygame.draw.line(screen, (r, g, b), (0, y), (int(SCREEN_WIDTH * 0.7), y))

# Create the board
def draw_board(action_positions):
    for row in range(GRID_SIZE):
        for col in range(GRID_SIZE):
            if row % 2 == 0:  # Even rows go right to left
                position = (GRID_SIZE * (GRID_SIZE - row - 1)) + (GRID_SIZE - col - 1) + 1
            else:  # Odd rows go left to right
                position = (GRID_SIZE * (GRID_SIZE - row - 1)) + col + 1

            rect = pygame.Rect(col * CELL_SIZE, row * CELL_SIZE + GRID_Y_OFFSET, CELL_SIZE, CELL_SIZE)
            pygame.draw.rect(screen, WHITE, rect)
            pygame.draw.rect(screen, BLACK, rect, 1)

            if position in action_positions:
                text = FONT.render(action_positions[position], True, BLACK)
            else:
                text = FONT.render(str(position), True, BLACK)

            screen.blit(text, (rect.x + 5, rect.y + 5))

# Generate snakes and ladders
def generate_snakes_and_ladders():
    snakes = {}
    ladders = {}

    while len(snakes) < 10:
        start = random.randint(11, 90)
        end = start - random.randint(1, 10)
        if end > 0 and start not in snakes and start not in ladders:
            snakes[start] = end

    while len(ladders) < 10:
        start = random.randint(1, 89)
        end = start + random.randint(1, 10)
        if end <= 100 and start not in ladders and start not in snakes:
            ladders[start] = end

    return snakes, ladders

snakes, ladders = generate_snakes_and_ladders()

# Draw snakes and ladders using custom styles
def draw_snakes_and_ladders():
    for start, end in snakes.items():
        start_pos = get_coordinates(start)
        end_pos = get_coordinates(end)

        # Create curvy wavy effect for snakes
        num_segments = 10  # Number of segments for the curve
        x_diff = (end_pos[0] - start_pos[0]) / num_segments
        y_diff = (end_pos[1] - start_pos[1]) / num_segments
        points = []
        for i in range(num_segments + 1):
            x = start_pos[0] + i * x_diff + CELL_SIZE // 6 * (-1)**i
            y = start_pos[1] + i * y_diff
            points.append((x + CELL_SIZE // 2, y + CELL_SIZE // 2))  # Center-align the wave

        pygame.draw.lines(screen, BLACK, False, points, 8)  # Draw the wavy snake

    for start, end in ladders.items():
        start_pos = get_coordinates(start)
        end_pos = get_coordinates(end)
        pygame.draw.line(screen, GOLD, (start_pos[0] + CELL_SIZE // 2, start_pos[1] + CELL_SIZE // 2),
                         (end_pos[0] + CELL_SIZE // 2, end_pos[1] + CELL_SIZE // 2), 5)  # Shiny golden ladder

# Convert board index to screen coordinates
def get_coordinates(position):
    position -= 1
    row = position // GRID_SIZE
    if row % 2 == 0:  # Even rows go right to left
        col = position % GRID_SIZE
    else:  # Odd rows go left to right
        col = GRID_SIZE - 1 - (position % GRID_SIZE)

    x = col * CELL_SIZE
    y = (GRID_SIZE - 1 - row) * CELL_SIZE
    return x, y

# Smooth movement animation
def animate_movement(start, end, player_index):
    step = 1 if end > start else -1
    for position in range(start, end + step, step):
        draw_gradient_background()
        draw_board(action_positions)
        draw_snakes_and_ladders()
        draw_players()
        draw_chat()
        draw_timer(countdown_end)

        x, y = get_coordinates(position)
        screen.blit(PLAYER_IMAGES[player_index], (x, y))  # Align image with cell
        pygame.display.flip()
        time.sleep(0.2)

# Load actions
def load_actions():
    actions = {
        "L1": ["Action for L1"],
        "L2": ["Action for L2"],
        "L3": ["Action for L3"],
        "L4": ["Action for L4"],
        "L5": ["Action for L5"],
        "L6": ["Action for L6"],
        "L7": ["Action for L7"],
        "L8": ["Action for L8"],
        "L9": ["Action for L9"],
        "L10": ["Action for L10"]
    }
    return actions

actions = load_actions()

def get_action(position):
    if 1 <= position <= 10:
        return random.choice(actions["L1"])
    elif 11 <= position <= 20:
        return random.choice(actions["L2"])
    elif 21 <= position <= 30:
        return random.choice(actions["L3"])
    elif 31 <= position <= 40:
        return random.choice(actions["L4"])
    elif 41 <= position <= 50:
        return random.choice(actions["L5"])
    elif 51 <= position <= 60:
        return random.choice(actions["L6"])
    elif 61 <= position <= 70:
        return random.choice(actions["L7"])
    elif 71 <= position <= 80:
        return random.choice(actions["L8"])
    elif 81 <= position <= 90:
        return random.choice(actions["L9"])
    elif 91 <= position <= 100:
        return random.choice(actions["L10"])
    else:
        return "No Action"

# Initialize players
def initialize_players():
    global PLAYER_IMAGES
    while True:
        try:
            num_players = int(input("Enter the number of players (2-4): "))
            if num_players == 2:
                player_names = ["Eros", "Psyche"]
                update_chat("Welcome Eros and Psyche!")
                PLAYER_IMAGES = load_player_images(2)
            elif num_players == 3:
                player_names = ["Ares", "Aphrodite", "Eos"]
                update_chat("Welcome Ares, Aphrodite, and Eos!")
                PLAYER_IMAGES = load_player_images(3)
            elif num_players == 4:
                player_names = ["Zeus", "Hera", "Semele", "Io"]
                update_chat("Welcome Zeus, Hera, Semele, and Io!")
                PLAYER_IMAGES = load_player_images(4)
            else:
                print("Invalid number of players. Please choose between 2 and 4.")
                continue
            break
        except ValueError:
            print("Invalid input. Please enter a number.")

    player_positions = [1 for _ in range(num_players)]
    return player_names, player_positions

players, player_positions = initialize_players()
current_player_idx = 0

def get_dice_value():
    global countdown_end
    input_value = ""
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                exit()

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_RETURN and input_value.isdigit() and 1 <= int(input_value) <= 6:
                    return int(input_value)
                elif event.key == pygame.K_BACKSPACE:
                    input_value = input_value[:-1]
                else:
                    input_value += event.unicode

        draw_gradient_background()
        draw_board(action_positions)
        draw_snakes_and_ladders()
        draw_players()
        draw_chat()
        draw_timer(countdown_end)
        input_text = FONT.render(f"Enter Dice Value (1-6): {input_value}", True, BLACK)
        screen.blit(input_text, (int(SCREEN_WIDTH * 0.7) + 5, SCREEN_HEIGHT - 40))
        pygame.display.flip()

# Draw players
def draw_players():
    for i, position in enumerate(player_positions):
        x, y = get_coordinates(position)
        screen.blit(PLAYER_IMAGES[i], (x, y))  # Align image with cell

# Main game loop
running = True
winner = None
action_positions = {}
countdown_end = time.time()
while running:
    draw_gradient_background()
    draw_board(action_positions)
    draw_snakes_and_ladders()
    draw_players()
    draw_chat()
    draw_timer(countdown_end)

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    if not winner:
        dice_value = get_dice_value()
        current_player = players[current_player_idx % len(players)]
        update_chat(f"{current_player} rolled a {dice_value}!")

        # Logic for rolling 6s
        six_count = 0
        turn_total = 0

        while True:
            if dice_value == 6:
                six_count += 1
                update_chat(f"{current_player} rolled a 6! Another chance!")
                if six_count == 3:
                    update_chat(f"{current_player} rolled three 6s! Turn skipped.")
                    break
                dice_value = get_dice_value()
            else:
                turn_total += 6 * six_count + dice_value
                new_pos = player_positions[current_player_idx] + turn_total

                if new_pos > 100:
                    update_chat("Roll exceeds 100! Stay in place.")
                else:
                    animate_movement(player_positions[current_player_idx], new_pos, current_player_idx)
                    player_positions[current_player_idx] = new_pos

                    countdown_end = time.time() + player_positions[current_player_idx] * 2  # Update timer

                    if new_pos in snakes:
                        update_chat(f"{current_player} encountered a snake! Sliding down.")
                        animate_movement(new_pos, snakes[new_pos], current_player_idx)
                        player_positions[current_player_idx] = snakes[new_pos]
                        countdown_end = time.time() + player_positions[current_player_idx] * 2

                    elif new_pos in ladders:
                        update_chat(f"{current_player} climbed a ladder! Moving up.")
                        animate_movement(new_pos, ladders[new_pos], current_player_idx)
                        player_positions[current_player_idx] = ladders[new_pos]
                        countdown_end = time.time() + player_positions[current_player_idx] * 2

                    action = get_action(player_positions[current_player_idx])
                    action_positions[player_positions[current_player_idx]] = action
                    update_chat(f"{current_player} performs: {action}")

                    if player_positions[current_player_idx] == 100:
                        winner = current_player
                        update_chat(f"{winner} wins the game! Congratulations!")

                break

        current_player_idx = (current_player_idx + 1) % len(players)

    pygame.display.flip()

pygame.quit()
