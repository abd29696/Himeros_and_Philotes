import pygame
import random
import time
import cv2

# Initialize Pygame
pygame.init()

# Screen dimensions
SCREEN_WIDTH, SCREEN_HEIGHT = 1200, 840
GRID_SIZE = 10
CELL_SIZE = int((SCREEN_WIDTH * 0.7) // GRID_SIZE)  # Adjusted cell size
GRID_Y_OFFSET = 0  # Removed top margin
CHAT_GRID_FONT = pygame.font.Font("font/GideonRoman-Regular.ttf", 19)
CHAT_FONT = pygame.font.Font("font/GideonRoman-Regular.ttf", 17)  # Updated font for chat
GRID_FONT = pygame.font.Font("font/GideonRoman-Regular.ttf", 25)  # Updated font for grid
TIMER_FONT = pygame.font.Font("font/GideonRoman-Regular.ttf", 19)  # Updated font

# Colors
TRANSPARENT = (0, 0, 0, 3)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
BLUE = (0, 0, 255)
YELLOW = (255, 255, 0)
GOLD = (255, 215, 0)

PLAYER_IMAGES = []

# Load Medusa and Hedone backgrounds
MEDUSA_BACKGROUND = pygame.transform.smoothscale(pygame.image.load("char/medusa/medusa1.png"), (int(SCREEN_WIDTH * 0.7), SCREEN_HEIGHT))
HEDONE_BACKGROUND = pygame.transform.smoothscale(pygame.image.load("char/hedone/hedone1.png"), (int(SCREEN_WIDTH * 0.7), SCREEN_HEIGHT))

MEDUSA_IMAGES = [
    pygame.image.load(f"char/medusa/medusa{i}.png") for i in range(1, 11)
]
HEDONE_IMAGES = [
    pygame.image.load(f"char/hedone/hedone{i}.png") for i in range(1, 11)
]

MEDUSA_IMAGES = [
    pygame.transform.smoothscale(image, (CELL_SIZE, CELL_SIZE))
    for image in MEDUSA_IMAGES
]
HEDONE_IMAGES = [
    pygame.transform.smoothscale(image, (CELL_SIZE, CELL_SIZE))
    for image in HEDONE_IMAGES
]

# Load single intro image
INTRO_IMAGE = pygame.transform.smoothscale(pygame.image.load("char/io.png"), (int(SCREEN_WIDTH), SCREEN_HEIGHT))

INTRO_VIDEO_PATH = "char/intro/intro.mp4"

def play_intro_video():
    cap = cv2.VideoCapture(INTRO_VIDEO_PATH)

    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break

        frame_height, frame_width = frame.shape[:2]
        aspect_ratio = 16 / 9
        if frame_width / frame_height > aspect_ratio:
            # Wider than 16:9, fit by height
            new_height = SCREEN_HEIGHT
            new_width = int(new_height * aspect_ratio)
        else:
            # Taller than 16:9, fit by width
            new_width = SCREEN_WIDTH
            new_height = int(new_width / aspect_ratio)

        frame = cv2.resize(frame, (new_width, new_height))
        frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        frame_surface = pygame.surfarray.make_surface(frame.swapaxes(0, 1))

        # Center the frame on the screen
        x_offset = (SCREEN_WIDTH - new_width) // 2
        y_offset = (SCREEN_HEIGHT - new_height) // 2
        screen.fill(WHITE)  # Clear the screen
        screen.blit(frame_surface, (x_offset, y_offset))
        pygame.display.flip()

        if cv2.waitKey(20) & 0xFF == ord('q'):
            break

    cap.release()
    cv2.destroyAllWindows()

def load_player_images(num_players):
    def load_high_quality_image(path):
        image = pygame.image.load(path).convert_alpha()
        return pygame.transform.smoothscale(image, (CELL_SIZE, CELL_SIZE))
    if num_players == 2:
        return [
            load_high_quality_image("char/eros.png"),
            load_high_quality_image("char/psyche.png")
        ]
    elif num_players == 3:
        return [
            load_high_quality_image("char/ares.png"),
            load_high_quality_image("char/aphrodite.png"),
            load_high_quality_image("char/eos.png")
        ]
    elif num_players == 4:
        return [
            load_high_quality_image("char/zeus.png"),
            load_high_quality_image("char/hera.png"),
            load_high_quality_image("char/semele.png"),
            load_high_quality_image("char/io.png")
        ]
    return []

# Initialize screen
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Hedone and Himeros")

# Chat panel setup
chat_panel = []
def update_chat(message):
    chat_panel.append(message)
    if len(chat_panel) > 15:
        chat_panel.pop(0)

def draw_timer(countdown_time):
    remaining_time = max(0, int(countdown_time - time.time()))
    minutes = remaining_time // 60
    seconds = remaining_time % 60
    timer_text = TIMER_FONT.render(f"Time Left: {minutes:02}:{seconds:02}", True, BLACK)
    panel_x = int(SCREEN_WIDTH * 0.7)
    screen.blit(timer_text, (panel_x + 10, 10))

def draw_chat():
    panel_x = int(SCREEN_WIDTH * 0.7)
    panel_width = SCREEN_WIDTH - panel_x
    chat_y_offset = int(SCREEN_HEIGHT * 0.1)

    # Draw the upper section for the timer
    pygame.draw.rect(screen, WHITE, (panel_x, 0, panel_width, chat_y_offset))
    pygame.draw.rect(screen, BLACK, (panel_x, 0, panel_width, chat_y_offset), 1)

    # Draw the lower section for the chat
    pygame.draw.rect(screen, WHITE, (panel_x, chat_y_offset, panel_width, SCREEN_HEIGHT - chat_y_offset))
    pygame.draw.rect(screen, BLACK, (panel_x, chat_y_offset, panel_width, SCREEN_HEIGHT - chat_y_offset), 1)

    padding = 15  # Padding between lines
    for i, line in enumerate(chat_panel):
        text = CHAT_FONT.render(line, True, BLACK)
        screen.blit(text, (panel_x + 10, chat_y_offset + 10 + i * padding))

# Create the board
def draw_board(action_positions, snake_tiles={}, ladder_tiles={}):
    for row in range(GRID_SIZE):
        for col in range(GRID_SIZE):
            if row % 2 == 0:  # Even rows go right to left
                position = (GRID_SIZE * (GRID_SIZE - row - 1)) + (GRID_SIZE - col - 1) + 1
            else:  # Odd rows go left to right
                position = (GRID_SIZE * (GRID_SIZE - row - 1)) + col + 1

            rect = pygame.Rect(col * CELL_SIZE, row * CELL_SIZE + GRID_Y_OFFSET, CELL_SIZE, CELL_SIZE)

            # Check if the tile should display a Medusa or Hedone image
            if position in snake_tiles:
                screen.blit(snake_tiles[position], rect.topleft)
            elif position in ladder_tiles:
                screen.blit(ladder_tiles[position], rect.topleft)

            overlay = pygame.Surface((CELL_SIZE, CELL_SIZE), pygame.SRCALPHA)
            overlay.fill((173, 216, 230, 8))  # Pastel blue with 30% opacity
            screen.blit(overlay, rect.topleft)
            pygame.draw.rect(screen, BLACK, rect, 1)

            text = GRID_FONT.render(str(position), True, BLACK)
            screen.blit(text, (rect.x + 5, rect.y + 5))

# Generate snakes and ladders
def generate_snakes_and_ladders():
    snakes = {}
    ladders = {}
    snake_medusa_mapping = {}
    ladder_hedone_mapping = {}

    for level_index, level_start in enumerate(range(1, 101, 10)):
        level_end = level_start + 9

        # Generate one snake per level
        while True:
            start = random.randint(level_start + 1, level_end)
            end = random.randint(level_start, start - 1)
            if start - end <= 5 and start not in snakes and start not in ladders and end > level_start:
                snakes[start] = end
                break

        # Assign the corresponding Medusa image to the snake
        snake_medusa_mapping[start] = MEDUSA_IMAGES[level_index % 10]


        # Generate one ladder per level
        while True:
            start = random.randint(level_start, level_end - 1)
            end = random.randint(start + 1, level_end)
            if end - start <= 5 and start not in ladders and start not in snakes:
                ladders[start] = end
                break

        # Assign the corresponding Hedone image to the ladder
        ladder_hedone_mapping[start] = HEDONE_IMAGES[level_index % 10]

    return snakes, ladders, snake_medusa_mapping, ladder_hedone_mapping

snakes, ladders, snake_medusa_mapping, ladder_hedone_mapping = generate_snakes_and_ladders()


# Draw snakes and ladders using custom styles
def draw_snakes_and_ladders():
    for start, end in snakes.items():
        start_pos = get_coordinates(start)
        end_pos = get_coordinates(end)

        # Create curvy wavy effect for snakes
        num_segments = 10  # Number of segments for the curve
        x_diff = (end_pos[0] - start_pos[0]) / num_segments
        y_diff = (end_pos[1] - start_pos[1]) / num_segments
        points = []
        for i in range(num_segments + 1):
            x = start_pos[0] + i * x_diff + CELL_SIZE // 6 * (-1)**i
            y = start_pos[1] + i * y_diff
            points.append((x + CELL_SIZE // 2, y + CELL_SIZE // 2))  # Center-align the wave

        # Snakes are now invisible
        pygame.draw.lines(screen, TRANSPARENT, False, points, 8)

    for start, end in ladders.items():
        start_pos = get_coordinates(start)
        end_pos = get_coordinates(end)
        # Ladders are now invisible
        pygame.draw.line(screen, TRANSPARENT, (start_pos[0] + CELL_SIZE // 2, start_pos[1] + CELL_SIZE // 2),
                         (end_pos[0] + CELL_SIZE // 2, end_pos[1] + CELL_SIZE // 2), 5)  # Draw the wavy snake

    for start, end in ladders.items():
        start_pos = get_coordinates(start)
        end_pos = get_coordinates(end)
        pygame.draw.line(screen, GOLD, (start_pos[0] + CELL_SIZE // 2, start_pos[1] + CELL_SIZE // 2),
                         (end_pos[0] + CELL_SIZE // 2, end_pos[1] + CELL_SIZE // 2), 5)  # Shiny golden ladder

# Convert board index to screen coordinates
def get_coordinates(position):
    position -= 1
    row = position // GRID_SIZE
    if row % 2 == 0:  # Even rows go right to left
        col = position % GRID_SIZE
    else:  # Odd rows go left to right
        col = GRID_SIZE - 1 - (position % GRID_SIZE)

    x = col * CELL_SIZE
    y = (GRID_SIZE - 1 - row) * CELL_SIZE
    return x, y

# Smooth movement animation
def animate_movement(start, end, player_index, background_override=None):
    step = 1 if end > start else -1
    for position in range(start, end + step, step):
        if background_override:
            screen.blit(background_override, (0, 0))  # Draw override background
        else:
            screen.fill(WHITE)  # Clear screen to white

        draw_board(action_positions, snake_tiles, ladder_tiles)
        draw_snakes_and_ladders()
        draw_players()
        draw_chat()
        draw_timer(countdown_end)

        x, y = get_coordinates(position)
        screen.blit(PLAYER_IMAGES[player_index], (x, y))  # Align image with cell
        pygame.display.flip()
        time.sleep(0.2)

# Load actions
def load_actions():
    actions = {
        "L1": ["Action for L1"],
        "L2": ["Action for L2"],
        "L3": ["Action for L3"],
        "L4": ["Action for L4"],
        "L5": ["Action for L5"],
        "L6": ["Action for L6"],
        "L7": ["Action for L7"],
        "L8": ["Action for L8"],
        "L9": ["Action for L9"],
        "L10": ["Action for L10"]
    }
    return actions

actions = load_actions()

def get_action(position):
    if 1 <= position <= 10:
        return random.choice(actions["L1"])
    elif 11 <= position <= 20:
        return random.choice(actions["L2"])
    elif 21 <= position <= 30:
        return random.choice(actions["L3"])
    elif 31 <= position <= 40:
        return random.choice(actions["L4"])
    elif 41 <= position <= 50:
        return random.choice(actions["L5"])
    elif 51 <= position <= 60:
        return random.choice(actions["L6"])
    elif 61 <= position <= 70:
        return random.choice(actions["L7"])
    elif 71 <= position <= 80:
        return random.choice(actions["L8"])
    elif 81 <= position <= 90:
        return random.choice(actions["L9"])
    elif 91 <= position <= 100:
        return random.choice(actions["L10"])
    else:
        return "No Action"

# Initialize players
def initialize_players():
    global PLAYER_IMAGES
    while True:
        try:
            num_players = int(input("Enter the number of players (2-4): "))
            if num_players == 2:
                player_names = ["Eros", "Psyche"]
                update_chat("Welcome Eros and Psyche!")
                PLAYER_IMAGES = load_player_images(2)
            elif num_players == 3:
                player_names = ["Ares", "Aphrodite", "Eos"]
                update_chat("Welcome Ares, Aphrodite, and Eos!")
                PLAYER_IMAGES = load_player_images(3)
            elif num_players == 4:
                player_names = ["Zeus", "Hera", "Semele", "Io"]
                update_chat("Welcome Zeus, Hera, Semele, and Io!")
                PLAYER_IMAGES = load_player_images(4)
            else:
                print("Invalid number of players. Please choose between 2 and 4.")
                continue

            # Show start image for 5 seconds
            # screen.blit(INTRO_IMAGE, (0, 0))
            # pygame.display.flip()
            # time.sleep(9)

            play_intro_video()

            break
        except ValueError:
            print("Invalid input. Please enter a number.")

    player_positions = [1 for _ in range(num_players)]
    return player_names, player_positions

players, player_positions = initialize_players()
current_player_idx = 0

def get_dice_value():
    global countdown_end
    input_value = ""
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                exit()

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_RETURN and input_value.isdigit() and 1 <= int(input_value) <= 6:
                    return int(input_value)
                elif event.key == pygame.K_BACKSPACE:
                    input_value = input_value[:-1]
                else:
                    input_value += event.unicode

        screen.fill(WHITE)  # Clear screen to white
        draw_board(action_positions, snake_tiles, ladder_tiles)
        draw_snakes_and_ladders()
        draw_players()
        draw_chat()
        draw_timer(countdown_end)
        input_text = CHAT_FONT.render(f"Enter Dice Value (1-6): {input_value}", True, BLACK)
        screen.blit(input_text, (int(SCREEN_WIDTH * 0.7) + 5, SCREEN_HEIGHT - 40))
        pygame.display.flip()

# Draw players
def draw_players():
    for i, position in enumerate(player_positions):
        x, y = get_coordinates(position)
        screen.blit(PLAYER_IMAGES[i], (x, y))  # Align image with cell

# Main game loop
running = True
winner = None
action_positions = {}
snake_tiles = {}
ladder_tiles = {}
countdown_end = time.time()
while running:
    screen.fill(WHITE)  # Clear screen to white
    draw_board(action_positions, snake_tiles, ladder_tiles)
    draw_snakes_and_ladders()
    draw_players()
    draw_chat()
    draw_timer(countdown_end)

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    if not winner:
        dice_value = get_dice_value()
        current_player = players[current_player_idx % len(players)]
        # update_chat(f"{current_player} rolled a {dice_value}!")

        # Logic for rolling 6s
        six_count = 0
        turn_total = 0

        while True:
            if dice_value == 6:
                six_count += 1
                if six_count == 3:
                    update_chat(f"{current_player} rolled three 6s! Turn skipped.")
                    break
                else:
                    update_chat(f"{current_player} rolled a 6! Another chance!")
                dice_value = get_dice_value()
            else:
                turn_total += 6 * six_count + dice_value
                new_pos = player_positions[current_player_idx] + turn_total

                if new_pos > 100:
                    update_chat("Roll exceeds 100! Stay in place.")
                else:
                    if new_pos in snakes:
                        animate_movement(player_positions[current_player_idx], new_pos, current_player_idx)
                        animate_movement(new_pos, snakes[new_pos], current_player_idx, MEDUSA_BACKGROUND)
                        update_chat(f"{current_player} encountered Medusa's wrath! You now need to get Spanked!")
                        snake_tiles[new_pos] = snake_medusa_mapping[new_pos]
                        player_positions[current_player_idx] = snakes[new_pos]
                        countdown_end = time.time() + player_positions[current_player_idx] * 2
                    elif new_pos in ladders:
                        animate_movement(player_positions[current_player_idx], new_pos, current_player_idx)
                        animate_movement(new_pos, ladders[new_pos], current_player_idx, HEDONE_BACKGROUND)
                        update_chat(f"{current_player} is embraced by Hedone’s delight and Himeros’ desire! You may now experience a delightful action of your choosing!")
                        ladder_tiles[new_pos] = ladder_hedone_mapping[new_pos]
                        player_positions[current_player_idx] = ladders[new_pos]
                        countdown_end = time.time() + player_positions[current_player_idx] * 2
                    else:
                        animate_movement(player_positions[current_player_idx], new_pos, current_player_idx)
                        player_positions[current_player_idx] = new_pos
                        countdown_end = time.time() + player_positions[current_player_idx] * 2

                    action = get_action(player_positions[current_player_idx])
                    update_chat(f"{current_player} performs: {action}")

                    if player_positions[current_player_idx] == 100:
                        winner = current_player
                        update_chat(f"{winner} wins the game! Congratulations!")

                break

        current_player_idx = (current_player_idx + 1) % len(players)

    pygame.display.flip()

pygame.quit()
